\section{Motivación}
Los compiladores son un pilar fundamental en la tecnología contemporánea. Estos han conseguido facilitar la programación construyendo capas de abstracción entre la máquina y el programador. Antes se programaba directamente en código ensamblador que después se traducía al código máquina para generar un ejecutable. A día de hoy, lo más común es programar en lenguajes de alto nivel como \textit{Python} o \textit{JavaScript}, donde hay miles de librerías y herramientas que ofrecen múltiples funcionalidades para que facilitar el desarrollo de software de cualquier tipo. \\
Se debe hacer una clara distinción entre compilador e interprete, el compilador traduce todo el código fuente del lenguaje original a código máquina, lo cual evidentemente le hace en la mayoría de casos más rápido. Sin embargo, el interprete convierte cada línea, una a una a código máquina teniendo en cuenta los resultados de líneas anteriores con técnicas como el conteo de referencias, garbage collection, etc... \\
En la primera parte de este trabajo hablaremos del desarrollo de un compilador. He escogido escribir un compilador porque siempre me ha interesado conocer lo que realmente ocurre en la computadora cuando tras escribir tu programa genera un ejecutable. Y porque creo que conocer detalles de programación de bajo nivel son de ayuda en el día a día de un programador. Además, conocer todas las etapas por las que pasa el código fuente hasta convertirse en código máquina te da una perspectiva global sobre la naturaleza de un lenguaje de programación de alto nivel.\\
En cuanto a la segunda parte del trabajo, los algoritmos de compresión siempre habían llamado mi atención. Sin embargo, nunca me había tomado el tiempo para analizar ninguno de ellos. Con este trabajo he tenido la oportunidad de profundizar en conceptos como los registros de desplazamiento, o las formulas lógicas que antes desconocía.\\
En conclusión, la motivación principal de este trabajo era conocer en mayor profundidad los compiladores y los algoritmos de compresión, que en cierta manera se entremezcla con algunos algoritmos de cifrado.

\section{Objetivos}
El primer objetivo de este proyecto era crear un compilador funcional del lenguaje BeGone, siguiendo las lecciones del curso de David Beazley. El curso contiene lecciones básicas para guiarte, algunos tests, y un compilador medio implementado para que compruebes si la salida de tu compilador coincide con la de este. Este compilador de ayuda deja de ser útil a partir de la implementación básica del módulo de generación de código llvm. A partir de ese punto, hay algunos tests, pero en general te las tienes que apañar solo. Por lo que la implementación es cien por cien escrita por el autor de este trabajo.\\\\
Después del desarrollo completo del compilador, mi tutor me ofreció un artículo \cite{limniotis2007nonlinear} donde había un algoritmo que daba salida a un polinomio basándose en una secuencia binaria. Y el problema planteado fue si ese polinomio era reducible, eso derivo a desarrollar un formato de archivo especial para este algoritmo. Y con este formato, implemente en el compilador original dos funciones nativas para codificar y decodificar un archivo. Evidentemente, esto provoco cambios en todas las etapas del compilador. Al hacer esto el compilador original paso de llamarse BeGone a GoneFSR. \\\\
El último de los objetivos fue desarrollar una memoria técnica donde todo fuera claro para el lector, para ello, tome como estructura de la sección del desarrollo del compilador, el documento \href{https://repositorio.unican.es/xmlui/handle/10902/30046}{intérprete Lox} ofrecido por mi tutor. Para la segunda parte del proyecto, los conceptos se explican desde los más sencillos hasta los más complejos, para que el lector no reciba estos últimos de golpe.

\section{Desarrollo software}
Para el desarrollo del compilador el modelo de desarrollo software utilizado ha sido el modelo incremental iterativo, tal y como se recomienda en el curso de BeGone. Este consiste en dividir el proyecto en etapas, y para cada etapa aplicar las distintas fases de desarrollo para producir un software sin errores. Estas etapas se desarrollan secuencialmente, aplicando pequeños incrementos en la complejidad del proyecto después de haberse asegurado que la etapa anterior estaba bien desarrollada. En cada incremento el objetivo es añadir o extender una funcionalidad en el proyecto global, a cada incremento se lo podría asociar con un hito si se conoce el \textit{framework} \textit{SCRUM}. \\\\
Al desarrollar el proyecto de esta manera puedes aplicar tests en cada etapa, haciendo así que el feedback dado por los tests tanto unitarios (caja negra) como de sistema (caja blanca) sea más fácil de entender y aplicar las correcciones necesarias implique menos trabajo. \\\\
En la práctica he creado un repositorio git en local y he trabajado sobre dos ramas una \textit{dev} y otra \textit{prod}. Haciendo commit en \textit{dev} por cada pequeño avance, y haciendo merge en \textit{prod} cada vez que completaba una etapa del desarrollo. Podéis consultar el código en \href{https://github.com/domingoUnican/TFGPedroCastro/tree/main/code}{repositorio}. \\\\
En el repositorio referenciado anteriormente no encontrareis el historial de logs pertinente. Ya que el compilador fue desarrollado en Mayo, y no subí el repositorio original a mi github. \\\\
Por último, respecto al desarrollo de \textit{scripts} y otros experimentos relacionados con la segunda parte del proyecto, no he seguido ningún estándar. Ya que solían ser pruebas separadas y no un proyecto global, que necesitase de planificación y estructura.