\section{Avances futuros}
En este trabajo se tocan muchos temas distintos. Cada uno de ellos puede expandirse mucho más de lo que se ha hecho aquí. Se me ocurren muchas posibilidades para expandir GoneFSR y la investigación de la minimización de ESOP (\textit{Exclusive Sum of Products}).\\\\
Para el compilador GoneFSR se podría trabajar en implementar operadores lógicos \textit{bitwise}, implementar instrucciones de control de flujo como \textit{break} o \textit{continue}. O en funcionalidades más complejas, como implementar paradigmas como OOP (\textit{Object Oriented Programming}) con sus respectivas clases, atributos y demás. Podría parecer complicado, pero creo que no lo es tanto ya que las clases no dejan de ser funciones, las cuales tienen otras funciones definidas dentro de su \textit{scope}. En un futuro, también me gustaría programar algún sistema de importaciones para poder trabajar sobre varios ficheros, teniendo en cuenta las importaciones circulares y otras casuísticas. Otra futura implementación podría ser la mejora en la administración de memoria con sistemas como la \textit{garbage collection} de Python que a partir de técnicas como el conteo de referencias, o el \textit{cycle detection} para evitar ciclos de referencias, gestionan la liberación de la memoria de las variables a las que no se hace referencia. Y por qué no, puestos a imaginar un gestor de módulos como \textit{pip} o \textit{npm}.\\\\
Por otro lado, se podría desarrollar un backend personalizado con optimizaciones de código usando vectorización con instrucciones SIMD (\textit{Single Instruction Multiple Data}), \textit{unrolling} para descomponer bucles y aumentar la paralelización del código, reordenación de instrucciones para minimizar tiempos de espera. Estas son sólo unas pocas líneas de investigación que se pueden seguir en el desarrollo de un backend de compilación.\\\\
En cuanto a la segunda parte del proyecto hay muchas cosas que he estado estudiando antes de escribir esta memoria que no han podido ser reflejadas en estas líneas ya que a pesar de que puede que tengan que ver, quedaban fuera de los límites del proyecto. Como por ejemplo conceptos como la síntesis de programación, la cual trata de generar programas que cumplan ciertos requisitos, estudiando algoritmos como la enumeración explicita e implícita, si queréis saber más podéis consultar estos artículos \href{https://people.csail.mit.edu/asolar/SynthesisCourse/Lecture1.htm}{\textit{programming synthesis}}. O novedosos avances del estado del arte de la inteligencia artificial, como los sistemas de agentes LLM (\textit{Large Language Model}) (p.ej \cite{islam2024mapcoder}) para generar programas con tan sólo una vaga descripción de lo requerido.\\\\
Donde más potencial de investigación en lo referido a las funciones de registro de desplazamiento estudiadas creo que existe es en la minimización de ESOP, destiné algún tiempo a estudiar el artículo \cite{mishchenko2001fast} y a estudiar código que encontre de su proyecto \textit{EXORCISM} para minimizar estas funciones lógicas. Me estaba llevando mucho tiempo y no conseguí llegar a nada en concreto, pero creo que con el suficiente tiempo se puede indagar en ese campo para buscar nuevas optimizaciones. Creo que otra aproximación adecuada para este problema de minimización podrían ser los SMT (\textit{Satisfacibility Modulo Theories}) como \textit{Z3}, y los SAT solvers, que hace relativamente poco consiguieron resolver el teorema de las tripletas booleanas pitagóricas en 4 años de CPU tal y como dice el matemático Terrence Tao en la \href{https://www.youtube.com/watch?v=e049IoFBnLA&t=1061s}{conferencia}.
\section{Conclusión}
Este proyecto ha llevado mucho trabajo, ha habido momentos muy frustrantes tanto en el desarrollo del compilador, como en la investigación de los algoritmos de registro de desplazamiento. Pero no me arrepiento en absoluto de haberme embarcado en esta empresa. \\\\
La implementación de las sentencias condicionales, trabajar con strings en llvm, añadir la capacidad de escribir funciones, parece poco pero son muchos problemas distintos a los que enfrentarse. Aunque es cierto, que una vez entiendes la estructura central del compilador cada extensión no es tan complicada pues al final son modificaciones de esa propia estructura.\\\\
Entender como funciona el algoritmo de la sección \ref{nlfsr algorithm} me llevo mucho tiempo, entender por qué se suma los minterms como se suman, el por qué del cálculo del \textit{eigenvalue}, conceptos como la complejidad de \textit{Lempel-Ziv} u otros de los que nunca había oído hablar. Intentar hacer un formato que sea óptimo para guardar la información de ese algoritmo. Todo esto fue como hacer un \textit{puzzle} en el que te dan las piezas pero no sabes cómo es la imagen final que deben de formar.\\\\
A modo de conclusión final, me gustaría reafirmar que este proceso aunque haya tenido sus malos ratos y sus momentos de satisfacción cuando todo cuadraba (o cuando parecía que todo cuadraba y al final no), creo que ha merecido la pena, y acabo el proyecto siendo un mejor ingeniero informático.